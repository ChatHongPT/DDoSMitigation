# Scripting_Guide

zeek는 이벤트기반 스크립팅 언어를 지원한다. <br>
zeek에서 생성된 모든 로그는 실제 zeek 스크립트에 의해 생성되고 있다. <br>

## 스크립트 문법

기본 변수선언

~~~zeek
# 이것은 주석 이다.

# 키워드 변수명: 타입 = 식;

# 키워드명
# global, local, const

# 배열 다루는 방법은 다양하다.
local my_list = ["abc", "def", "ghi"]; # 배열 선언시 ':' 생략 가능



# vector 사용법
local my_list = vector(1, 2, 3, 4); # 초기화시 입력한 값에 따라 타입이 자동으로 지정된다.
local my_list2: vector of count;

my_list2 += 3; # vector는 이런 식으로 배열 요소를 추가할 수 있다.
my_list2 += 64;
my_list2 += 23;

print my_list2[0] # 배열 접근은 이렇게 하면 된다.



# set 사용법
local my_list: set[string] = {"abc", "def", "ghi"};

local my_list2 = set( 23/tcp, 80/tcp, 143/tcp, 25/tcp ); # 초기화시 입력한 값에 따라 타입이 자동으로 지정된다.

add my_list["jkl"]; # 배열 요소 추가 시 사용된다.
add mylist2[443/tcp];



# table 사용법
local my_list: table[string] of string # table[타입1, 타입2, 타입3, ...] of 저장할 데이터 타입;

my_list5["cat"] = "meow!";
my_list5["dog"] = "bow! wow!!";

local my_list2: table[string, string, int] of string;

my_list2["man", "south_korea", 21] = "hong guil dong";
my_list2["woman", "south_america", 23] = "kate";



# type 사용법

type Service: record { # C언어의 typedef struct와 사용법이 유사하다.
    name: string;
    ports: set[port];
    rfc: count;
};

local http: Service = [$name="http", $ports=set(80/tcp, 8080/tcp), $rfc=2616];

print http$name; # 접근은 '$'로 한다.





~~~
타입 목록

|타입명|의미|
|:----:|:----:|
|bool|참/거짓|
|int|정수|
|count|양의 정수|
|double|부동 소수점 숫자|
|time|시간 값|
|interval|시간 간격|
|string|문자열|
|pattern|정규 표현식|
|port|포트 번호|
|addr|IP 주소|
|subnet|서브넷 주소|
|enum|열거형 타입|
|table|키-값 쌍의 집합|
|set|값의 집합|
|vector|순서가 있는 값의 집합|
|record|구조체 타입|
|function|함수 타입|
|event|이벤트 타입|
|hook|훅 타입|
|file|파일 타입|
|opaque|불투명 타입|
|any|모든 타입을 포함하는 타입|

출력

~~~zeek
print fmt("Hello World!"); # C 언어의 printf와 사용법이 유사하다. (%d, %s, %lf 지원)

print 출력할 변수; # Python 2.X 버전의 print 사용법과 유사하다.

print "이렇게도", "출력할 수 있습니다.", 변수명;


~~~

fmt 서식 지정자

|서식 지정자|의미|
|:--:|:------:|
|%d|정수형 변수|
|%f|실수형 변수|
|%s|문자열 변수|
|%b|부울린 변수|
|%t|시간 변수|
|%p|포트 변수|
|%h|호스트 변수|
|%n|네트워크 변수|

조건문
~~~zeek
if(조건식){
    실행문;
}
else{
    실행문;
}
~~~

반복문
~~~zeek
for(초기화, 초기화1, 초기화2... in 문자열 또는 배열){
  실행문;
}

for(초기화 in 1 | 5){ # Python의 반복문과 사용법이 유사하다.
    실행문;
}

while(조건식){ 
    실행문;
}


~~~

이벤트 처리
~~~zeek
# 특정 이벤트가 발생했을 때 이벤트 핸들러가 처리해준다.

event 이벤트명(c:connection, 매개변수){
    실행문;
}
~~~

이벤트 목록

|이벤트 핸들러|기능|
|:----:|:----:|
|packet_received|네트워크로부터 패킷을 수신할 때마다 호출|
|http_request|HTTP 요청이 감지되었을 때 호출|
|ssl_established|SSL 연결이 설정되었을 때 호출|
|notice|비정상적인 네트워크 활동이 감지될 때 호출|
|connection_state_change|TCP 연결의 상태가 변경될 때 호출|
|file_new|새로운 파일이 전송되거나 다운로드될 때 호출|
|dns_request/dns_reply|DNS 요청이 발생하거나 응답이 수신되었을 때 호출|

함수
~~~zeek

# event는 특정 이벤트 발생 시 자동 호출이 되지만 function은 일반적인 프로그래밍 언어처럼 사용자 정의로 필요할 때 호출하는 것이다.
# 함수 호출 방법도 프로그래밍 언어와 동일하다.

function 함수명(매개변수){
    실행문;
}

# export 키워드 사용 시 외부에서도 사용할 수 있게 된다.
export function 함수명(매개변수){
    실행문;
}

# 추가로 export는 이렇게도 사용할 수 있다.
export { 
    데이터;
}

# 불러오는건 다음과 같이 불러온다.
@load export가 있는 파일명

~~~

모듈
~~~zeek

module 모듈명;

~~~

모듈에는 여러가지 종류가 있다.

Base 모듈:
Zeek의 기본 기능을 제공하는 핵심 모듈이다. <br>
네트워크 트래픽 분석, 로깅, 정책 실행 등의 기능을 포함한다.

|모듈|기능|
|:----:|:----:|
|conn.log|연결 정보 로깅|
|http.log|HTTP 트래픽 로깅|
|dns.log|DNS 트래픽 로깅|
|files.log|파일 전송 정보 로깅|


Protocols 모듈:
다양한 네트워크 프로토콜을 분석하는 모듈들이 포함되어 있다. <br>
HTTP, DNS, FTP, SSH 등의 프로토콜을 지원한다.
|모듈|기능|
|:----:|:----:|
|http|HTTP 프로토콜 분석|
|dns|DNS 프로토콜 분석|
|ftp|FTP 프로토콜 분석|
|ssh|SSH 프로토콜 분석|


Frameworks 모듈:
특정 기능을 제공하는 프레임워크 모듈들이다. <br>
인텔리전스 프레임워크, 파일 분석 프레임워크 등이 있다.
|모듈|기능|
|:----:|:----:|
|intel|인텔리전스 프레임워크|
|files|파일 분석 프레임워크|
|signatures|시그니처 기반 탐지 프레임워크|


Policy 모듈:
보안 정책 실행을 위한 모듈들이다. <br>
악성코드 탐지, 이상 행위 탐지 등의 기능을 제공한다.
|모듈|기능|
|:----:|:----:|
|notice|이벤트 알림 정책|
|scan|스캔 탐지 정책|
|weird|비정상 행위 탐지 정책|
|software|소프트웨어 버전 탐지 정책|


Auxiliary 모듈:
보조적인 기능을 제공하는 모듈들이다. <br>
로깅 관리, 통계 분석 등의 기능을 포함한다.
|모듈|기능|
|:----:|:----:|
|logging|로깅 관리|
|stats|통계 분석|
|reporter|보고서 생성|

기타 모듈 및 자세한 사용법 : https://docs.zeek.org/en/master/script-reference/packages.html#protocols

스크립트 적용방법

~~~zeek
zeek -i 이더넷 명 스크립트 파일
~~~

위와같이 하면 스크립트는 실행될 것이고 로그 파일은 현재작업 디렉토리에 출력한다.
